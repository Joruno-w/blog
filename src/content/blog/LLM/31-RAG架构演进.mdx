---
title: RAG架构演进
description: RAG架构演进
pubDate: 2025-10-09
toc: true
ogImage: true
category: LLM
---

RAG 的概念和思想最早是在 2020 年由 Meta 公司的技术团队在文章 [“Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks”](https://proceedings.neurips.cc/paper/2020/file/6b493230205f780e1bc26945df7481e5-Paper.pdf) 中正式提出的，用于给当时已经开始出现的大型预训练语言模型提供来自外部的 **非参数化** 的信息与记忆，从而改善语言生成的效果。

> [!tip]
>
> **非参数化** 的信息与记忆指的是不包含在模型权重中的知识内容。训练语料库之外的信息。

同济大学智能自主系统上海研究所等团队在 2024 年年初发表勒一篇研究报告 [“Retrieval-Augmented Generation for Large Language Models”](https://arxiv.org/pdf/2312.10997)，将 RAG 范式与架构的演进分成了 3 个阶段：

1. Native RAG 阶段
2. Advanced RAG 阶段
3. Modular RAG 阶段

## Native RAG 阶段

包含 3 个主要的模块与阶段：

1. 索引
2. 检索
3. 生成

<img
  src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-05-28-014544.png"
  alt="image-20250528094543784"
  style="zoom:50%;"
/>

## Advanced RAG 阶段

1. 检索前处理
2. 检索后处理

### 检索前处理

Pre-Retrieval

🤔 需要处理啥？

检索前处理通常用于完成诸如 **查询转换**、**查询扩充**、**检索路由**等处理工作，其目的是为后面的检索和检索后处理做必要的准备，以便提高检索阶段 **召回知识** 的精确度与最终生成的质量。

**查询转换（Query Rewriting）**

将用户的原始问题“重写”为一个更清晰、更标准、更检索友好的表达方式。例如：

| 原始问题                     | 转换后查询                       |
| ---------------------------- | -------------------------------- |
| “这个 App 支不支持退款？”    | “App 退款政策是什么？”           |
| “我买的耳机怎么一直没声音？” | “耳机无声音的常见原因与解决方法” |

**查询扩充（Query Expansion）**

在不改变用户意图的前提下，**添加相关词语或同义表达**，让检索系统能够匹配到更多语义相关的文档。例如用户输入：

```
项目合同
```

扩充后的 Query 变成了：

```
["项目合同", "合作协议", "法律文件", "合同模板"]
```

这类操作能显著提高召回率，避免“字不对字”导致遗漏。

**检索路由（Retrieval Routing）**

在准备外挂语料库（知识库）的时候，往往会有多个语料库。

针对不同类型的问题，选择不同的知识库或不同的检索方式，实现多路检索策略。例如：

| 用户问题                       | 路由策略说明                             |
| ------------------------------ | ---------------------------------------- |
| “这款产品电池容量是多少？”     | 路由到【产品参数知识库】                 |
| “怎么退货？”                   | 路由到【客服 FAQ 知识库】                |
| “能再详细说明一下工作原理吗？” | 路由到【技术文档知识库】，或使用多跳检索 |

**召回率（Recall）**

指的是所有相关内容中被成功检索出来的比例。公式为：

```
召回率 = 检索到的相关内容数量 / 所有实际相关内容的总数
```

例如：实际相关文档有 10 个，系统只检索到其中 6 个，那么召回率 = 6 / 10 = 60%

**精确率（Precision）**

指的是检索出来的所有内容中，真正相关的占比。公式为：

```
精确率 = 检索到的相关内容数量 / 检索到的所有内容数量
```

例如：实际相关文档有 10 个，系统共返回 8 个文档，其中 6 个是相关的，那么精确率 = 6 / 8 = 75%

也就是说，召回率反映的是系统的**覆盖能力**，而精确率衡量的是系统的**准确性**。

### 检索后处理

Post-Retrieval

检索后对检索出的相关知识块做必要的补充处理的阶段。

即使用了很优秀的向量搜索，检索回来的 Top-K chunks 仍然可能存在这些问题：

1. 内容相关性差：向量相似度高但语义上与用户问题不匹配
2. 信息冗余：多个 chunks 说的是同一件事，浪费词元空间
3. 有害内容：包含过时、不合法、敏感内容
4. 结构混乱：拼接后的上下文缺少逻辑、排序不合用户意图

因此需要对检索结果进行进一步处理，确保大模型接收到的上下文内容是「最相关 + 最高质量 + 最结构化」的。

常见的处理有：

1. 重排序（Reranking）
2. 过滤无关内容（Filtering）
3. 合并去重（Merging）
4. 精简摘要（Summarization）
5. 格式优化（Structuring）

经过了这些后处理之后，能够使得最需要、最合规的知识块处于上下文的最前端，从而有助于提高大模型的输出质量。

## Modular RAG 阶段

Native RAG 和 Advanced RAG 都是**链式的、顺序式的** RAG 范式。

Modular RAG 超越了这两种传统的 RAG 范式，展示了一种更灵活、更自由、更具高度扩展性的 RAG 范式。

Modular RAG 的基本思想如下：分模块

将 RAG 应用中的各个阶段细分成多个模块类、模块与算法。

- 模块类：代表 RAG 应用中的一个核心流程，比如预检索、检索中、检索后处理
- 模块：代表一个核心流程中的功能模块，比如预检索中的查询转换、查询扩充
- 算法：代表模块的一种实现方法，比如光查询转换就可以有普通重写、后退式重写、HyDE 重写等好几种方式

🤔 Modular RAG 的好处？

极大的提高了系统的可扩展性和灵活性。

---

-EOF-
