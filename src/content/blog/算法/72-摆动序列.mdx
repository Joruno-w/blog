---
title: 摆动序列
description: 摆动序列
pubDate: 2025-10-10
toc: true
ogImage: true
category: 算法
---

## 题目

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

示例 1

> 输入：nums = [1,7,4,9,2,5]
> 输出：6
> 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。

示例 2

> 输入：nums = [1,17,5,10,13,15,10,5,16,8]
> 输出：7
> 解释：这个序列包含几个长度为 7 摆动序列。
>
> （16, -12, 5, 3, 2, -5, -5, 11, -8）本来上面的序列计算出来插值，无法构成摆动序列
>
> 但是现在就是要把能够构成摆动序列的数值给提取出来。
>
> 能够构成摆动序列的最长子序列，其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。

示例 3

> 输入：nums = [1,2,3,4,5,6,7,8,9]
> 输出：2
>
> 仅仅只能提取出一个正数的插值，因此子序列的长度为2

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

**代码实现**

```js
/**
 * nums - 整数数组
 */
function wiggleMaxLength(nums) {
  // 如果数组长度小于2，直接返回数组长度，因为只有一个数字或者两个不同数字的序列本身就是摆动序列
  if (nums.length < 2) return nums.length

  let preDiff = 0 // 用来记录上一次相邻两个数字的插值
  let count = 1 // 当前摆动序列的长度，至少为1

  // 遍历数组里面所有的数，从第二个数开始
  for (let i = 1; i < nums.length; i++) {
    // 1. 先计算插值
    const diff = nums[i] - nums[i - 1]

    // 如果 diff > 0 && preDiff <= 0，说明当前出现了正差，前一个差值要么是负数，要么是0（一开始还未确定方向的情况）
    // diff < 0 && preDiff >= 0，说明当前出现了负差，前一个差值要么是正数，要么是0（一开始还未确定方向的情况）
    if ((diff > 0 && preDiff <= 0) || (diff < 0 && preDiff >= 0)) {
      count++ // 符合摆动条件，摆动计数器+1
      preDiff = diff // 更新差值
    }
  }

  return count
}
```

---

-EOF-
