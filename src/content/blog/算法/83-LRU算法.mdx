---
title: LRU算法
description: LRU算法
pubDate: 2025-10-10
toc: true
ogImage: true
category: 算法
---

LRU **缓存淘汰算法**就是一种常用的策略，全称为 Least Recently Used，也就是我们认为最近使用过的数据应该是 “有用的”，很久没有用过的数据应该就是无用的，内存满了就应该先删除那些很久没用过的数据。

**题目描述**

首先要接收一个 capacity 参数作为缓存容量的最大容量，然后实现两个 API，一个是 `PUT(key, val)` 方法存入键值对，另一个是 `get(key)` 方法获取 key 对应的 val，如果 key 不存在则返回 -1.

注意，get 和 put 方法都必须是 `O(1)` 的时间复杂度。下面是对应的测试用例：

```js
// 缓存容量为2
LRUCache cache = new LRUCache(2);
// 你可以把 cache 理解为一个队列
// 假设左边是队头，右边是队尾
// 最近使用的排在队头，久未使用的排在队尾
// 圆括号表示键值对

cache.put(1, 1);
// cache = [(1, 1)]

cache.put(2, 2);
// cache = [(2, 2), (1, 1)]

cache.get(1); // 返回 1
// cache = [(1, 1), (2, 2)]
// 因为最近访问了键 1，所以提至队头
// 返回键 1 对应的值 1

cache.put(3, 3);
// cache = [(3, 3), (1, 1)]
// 缓存容量已满，需要删除内容空出位置
// 优先删除久未使用的数据，也就是队尾的数据
// 然后把新的数据插入到队头

cache.get(2) // 返回-1（未找到）
// cache = [(3, 3), (1, 1)]
// cache 中已经不存在键为 2 的数据

cache.put(1, 4)
// cache = [(1, 4), (3, 3)]
// 键1已经存在，更新对应的值，并将其提前到队头
```

**LRU算法设计**

cache 这个数据结构必备的条件如下：

1. 显然 cache 中的元素**必须有序**，从而可以区分最近使用和久未使用的数据，当容量满了之后要删除最久未使用的那个元素来腾出位置。
2. 要在 cache 中快速找到某个 key 是否存在并得到对应的 val
3. 每次访问 cache 中的某个 key，**需要将这个元素变为最近使用的**，也就是说 cache 要支持在任意位置的快速插入和删除元素。

🤔什么数据结构同时符合上述条件呢？

- 哈希表：查找非常快，但是数据没有固定的顺序
- 链表：有顺序之分，插入和删除速度也很快，但是查找比较慢

这里可以将两者结合一下，形成一种复合类型的数据结构：哈希链表（LinkedHashMap）

![image-20250327100953202](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-03-27-020953.png)

借助这个结构，我们逐一分析上面 3 个条件：

1. 如果每次默认从链表尾部添加元素，那么显然越靠近尾部的元素就是最近使用的，越靠近头部的元素就是越久未使用的。
2. 对于某一个 key，可以通过哈希表快速定位到链表中的节点，从而取得对应的 val
3. 链表显然是支持在任意位置快速插入和删除的，改改指针就可以了。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 key 快速映射到任意一个链表节点，然后进行插入和删除。

🙋为什么这里需要使用双向链表？

回答：因为我们需要在删除一个节点的时候，操作该节点的前驱节点，通过双向链表可以快速查找到一个节点的前驱节点。
