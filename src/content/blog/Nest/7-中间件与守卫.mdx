---
title: 中间件与守卫
description: 中间件与守卫
pubDate: 2025-10-14
toc: true
ogImage: true
category: Nest
---

## AOP在Nest中的应用

### 1、中间件

中间件是 Express 里的概念，Nest 的底层默认是 Express，它在请求流程中的位置大致如下：

![image-20250116155649092](/img/nestjs-1760441098991-155-image-20250116155649092.png)

**中间件**可以在**路由处理程序之前**或者**之后插入**需要执行的任务，Nest做了进一步细分，主要分为**全局中间件**和**局部中间件**

我们可以通过命令**nest g mi [中间件名称]**直接来创建中间件，比如`nest g mi person`就会自动帮我们在`person`文件夹下创建`person.middleware.ts`文件

**person.middleware.ts**

```typescript
import { Injectable, NestMiddleware } from '@nestjs/common'
import { Request, Response, NextFunction } from 'express'

@Injectable()
export class PersonMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    console.log('before 中间件 ---' + req.url)
    next()
    console.log('after 中间件 ---' + res.statusCode)
  }
}
```

当然，默认生成的参数`req`，`res`类型都是`any`，next就是一个默认函数`() => void`我们可以加上`express`对应的相关类型。

我们可以在person模块中调用中间件

**person.module.ts**

```typescript
import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common'
import { PersonService } from './person.service'
import { PersonController } from './person.controller'
import { PersonMiddleware } from './person.middleware'

@Module({
  controllers: [PersonController],
  providers: [PersonService],
})
export class PersonModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(PersonMiddleware).forRoutes(PersonController)
  }
}
```

当然，我们也可以像下面一样，指定特定的路由：

```typescript
import {
  MiddlewareConsumer,
  Module,
  NestModule,
  RequestMethod,
} from '@nestjs/common'
import { PersonService } from './person.service'
import { PersonController } from './person.controller'
import { PersonMiddleware } from './person.middleware'

@Module({
  controllers: [PersonController],
  providers: [PersonService],
})
export class PersonModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(PersonMiddleware).forRoutes({
      path: '/person',
      method: RequestMethod.GET,
    })
  }
}
```

当我们访问/person时，后端打印如下效果：

```text
before 中间件 ---/person
person controller
after 中间件 ---200
```

在Nest中，类中间件不仅可以处理HTTP请求和响应，更重要的是，它能够实现依赖注入。这意味着我们可以在中间件中注入特定的依赖项，并且调用这些依赖项内部的方法。比如:

```typescript
import { Inject, Injectable, NestMiddleware } from '@nestjs/common'
import { Request, Response, NextFunction } from 'express'
import { UserService } from 'src/user/user.service'
import { PersonService } from './person.service'

@Injectable()
export class PersonMiddleware implements NestMiddleware {
  @Inject(PersonService)
  private personService: PersonService

  use(req: Request, res: Response, next: NextFunction) {
    console.log('before 中间件 ---' + req.url)
    console.log('调用注入的服务 ---' + this.personService.findAll())
    next()
    console.log('after 中间件 ---' + res.statusCode)
  }
}
```

当然，如果不需要依赖注入的话，也能使用轻量的函数中间件，就和定义普通函数差别不大

```typescript
export function PersonMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
) {
  console.log('before 函数中间件 ---' + req.url)
  next()
  console.log('after 函数中间件 ---' + res.statusCode)
}
```

除了在局部引用，也能**直接在全局引用**，作为全局中间件使用，比如，我创建一个logger中间件，`nest g mi logger`

```typescript
import { Injectable, NestMiddleware } from '@nestjs/common'
import { Request, Response, NextFunction } from 'express'
@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    console.log('before 全局中间件 ---' + req.url)
    next()
    console.log('after 全局中间件 ---' + res.statusCode)
  }
}
```

在main.ts中全局引入

```typescript
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'
import { LoggerMiddleware } from './logger/logger.middleware'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  app.use(new LoggerMiddleware().use)
  await app.listen(8088)
}
bootstrap()
```

### 2、守卫

守卫的职责一般很明确，通常用于权限、角色等授权操作，守卫所在的位置与中间件类似，可以对请求进行拦截和过滤，其实，Guard 就可以理解为**路由守卫**的意思，可以用于在调用某个 Controller 之前判断权限，返回 **true** 或者 **false** 来决定是否放行

![image-20250116160157181](/img/nestjs-1760441098997-198-image-20250116160157181.png)

**守卫在调用路由程序之前返回`true`或者`false`来判断是否通行**，同样分为**全局守卫**和**局部守卫**

同样，我们可以使用命令**nest g gu [守卫名称]**来创建守卫模块，比如：`nest g gu person`就会自动帮我们在`person`文件夹下创建`person.guard.ts`文件

要作为一个守卫，必须实现`CanActive`接口中的`canActivate()`方法

**person.guard.ts**

```typescript
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common'
import { Observable } from 'rxjs'

@Injectable()
export class PersonGuard implements CanActivate {
  canActivate(
    context: ExecutionContext
  ): boolean | Promise<boolean> | Observable<boolean> {
    console.log('person guard')
    return true
  }
}
```

如果我们进行局部绑定，可以直接在`Controller`类上添加装饰器`@UseGuards`

```typescript
@Controller('person')
@UseGuards(PersonGuard)
export class PersonController {......}
```

这样，当我们访问`/person`时，打印如下效果：

```text
before 中间件 ---/person
person guard
after 中间件 ---200
person controller
```

但是如果在`canActivate`方法中返回的是`false`，就会是如下效果

```typescript
{"message":"Forbidden resource","error":"Forbidden","statusCode":403}
```

`Controller` 本身不需要做啥修改，**却透明的加上了权限判断的逻辑，这就是 AOP 架构的好处**

而且，就像 Middleware 支持全局级别和路由级别一样，**Guard 也可以全局启用**

```diff
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.use(new LoggerMiddleware().use);
+  app.useGlobalGuards(new PersonGuard());
  await app.listen(8088);
}
bootstrap();
```

这样每个路由都会应用这个 Guard。

但是，**注意**，这种方式是通过自己**new的 Guard 实例，不在 IoC 容器里**。这会造成什么问题呢？由于没有在IoC容器中所以，当然无非获取从容器中注入的内容，比如像下面的代码：

```typescript
@Injectable()
export class PersonGuard implements CanActivate {
  @Inject(PersonService)
  private personService: PersonService

  canActivate(
    context: ExecutionContext
  ): boolean | Promise<boolean> | Observable<boolean> {
    console.log('person guard ---' + this.personService.findAll())
    return true
  }
}
```

在`PersonGuard`中引入了`PersonService`，但是这需要从IoC容器中进行注入，而我们的`PersonGuard`是自己new出来的，并没有被IoC容器所托管，因此，在这里是用不了PersonService对象的，会在后台直接报错，直接前台提示500错误。

```typescript
ERROR [ExceptionsHandler] Cannot read properties of undefined (reading 'findAll')

{"statusCode":500,"message":"Internal server error"}
```

所以，Nest还给我们提供了**另外一种全局注册方式**，在 AppModule 里声明，**当然记得把之前new的Guard实例注释掉**：

```diff
+import { APP_GUARD } from '@nestjs/core';
+import { PersonGuard } from './person/person.guard';

@Module({
  imports: [UserModule, PersonModule],
  controllers: [AppController, PersonController],
  providers: [
    AppService,
    PersonService,
+   {
+      provide: APP_GUARD,
+      useClass: PersonGuard,
+    },
  ],
})
export class AppModule {}
```
