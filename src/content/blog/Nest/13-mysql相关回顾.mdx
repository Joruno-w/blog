---
title: mysql相关回顾
description: mysql相关回顾
pubDate: 2025-10-14
toc: true
ogImage: true
category: Nest
---

## 数据表关系

所有的数据表之间有三种关系：

- 一对一
- 一对多
- 多对多

## 一对一

一对一就是，我只有你，你只有我。

比如：

- 用户与用户详情信息的关系。
- 商品与商品详情信息的关系。

即使是一对一也要明确**主从关系**，比如用户与用户详情的关系，用户是主，用户详情是从，因为没有用户哪里来的用户详情呢？再比如没有商品哪来的商品详情信息呢？

比如下面的例子，用户和用户详情信息

```sql
CREATE TABLE user(
	id INT UNSIGNED PRIMARY KEY auto_increment,
	name CHAR(30) DEFAULT NULL
);

CREATE TABLE user_detail(
	id INT UNSIGNED PRIMARY KEY auto_increment,
	card_no VARCHAR(20) NOT NULL,
	user_id INT UNSIGNED,
	CONSTRAINT user_detail_person FOREIGN KEY (user_id) REFERENCES user(id)
)
```

> 当然，还有一对一的处理是直接用两张表的主键对主键

插入数据

![image-20250201135235705](/img/nestjs-1760441099154-376-image-20250201135235705.png)

![image-20250201135254824](/img/nestjs-1760441099155-544-image-20250201135254824.png)

然后查询所有用户的姓名和对应的身份证号：

```sql
SELECT u.id, u.name, ud.card_no
FROM user u LEFT JOIN user_detail ud
ON u.id=ud.user_id;
```

![image-20250201135532618](/img/nestjs-1760441099156-599-image-20250201135532618.png)

## 一对多

一对多(多对一)，即主表的一个数据可以有多个从表的数据。
比如：班级和学生，一个班级有多个学生，一个学生对应一个班级，主表是班级，从表是学生

```sql
CREATE TABLE class(
	id INT UNSIGNED PRIMARY KEY auto_increment,
	class_name VARCHAR(30) COMMENT '班级名'
);

CREATE TABLE student(
	id INT UNSIGNED PRIMARY KEY auto_increment,
	student_name CHAR(30) COMMENT '学生名',
	class_id INT UNSIGNED DEFAULT NULL COMMENT '班级id',
	CONSTRAINT student_class FOREIGN KEY (class_id) REFERENCES class(id)
);

-- 创建表的数据库名是students
INSERT INTO `students`.`class` (`class_name`) VALUES ('一班');
INSERT INTO `students`.`class` (`class_name`) VALUES ('二班');
INSERT INTO `students`.`class` (`class_name`) VALUES ('三班');

INSERT INTO `students`.`student` (`student_name`, `class_id`) VALUES ('张三', '1');
INSERT INTO `students`.`student` (`student_name`, `class_id`) VALUES ('李四', '2');
INSERT INTO `students`.`student` (`student_name`, `class_id`) VALUES ('王五', '3');
INSERT INTO `students`.`student` (`student_name`, `class_id`) VALUES ('赵六', '1');
INSERT INTO `students`.`student` (`student_name`, `class_id`) VALUES ('丽丽', '1');
INSERT INTO `students`.`student` (`student_name`, `class_id`) VALUES ('李磊', '2');
INSERT INTO `students`.`student` (`student_name`, `class_id`) VALUES ('韩梅梅', '3');
```

![image-20250201140625105](/img/nestjs-1760441099156-137-image-20250201140625105.png)

![image-20250201140647014](/img/nestjs-1760441099156-687-image-20250201140647014.png)

我们当然就可以查询哪些班级下有那些学生

```sql
SELECT c.id, c.class_name,s.student_name
FROM class c INNER JOIN student s ON c.id=s.class_id
```

![image-20250201140849967](/img/nestjs-1760441099157-19-image-20250201140849967.png)

当然，我们也能够实现统计：

```sql
SELECT c.id, c.class_name, COUNT(s.student_name) student_num
FROM class c LEFT JOIN student s ON c.id=s.class_id
GROUP BY c.id;
```

![image-20250201141021823](/img/nestjs-1760441099157-373-image-20250201141021823.png)

## 多对多

三种关系里，多对多是最复杂的。
比如：一篇文章有可以有多种分类，一种分类可以有多篇文章。

由于多对多的关系比较复杂，我们一般会添加一张**中间表**专门来记录他们的关系。

```sql
-- 分类表
CREATE TABLE tag(
	id INT UNSIGNED PRIMARY KEY auto_increment,
	tag_name VARCHAR(50) NOT NULL
);

-- 文章表
CREATE TABLE article(
	id INT UNSIGNED PRIMARY KEY auto_increment,
	title VARCHAR(100) NOT NULL
);

-- 分类文章中间表
CREATE TABLE tag_article(
	id INT UNSIGNED PRIMARY KEY auto_increment,
	tag_id INT UNSIGNED DEFAULT NULL,
	article_id INT UNSIGNED DEFAULT NULL,
	FOREIGN KEY(tag_id) REFERENCES tag(id) ON DELETE CASCADE ON UPDATE CASCADE,
	FOREIGN KEY(article_id) REFERENCES article(id) ON DELETE CASCADE ON UPDATE CASCADE,
	UNIQUE(tag_id,article_id)
)

-- 插入分类表数据
INSERT INTO `students`.`tag` (`tag_name`) VALUES ('玄幻');
INSERT INTO `students`.`tag` (`tag_name`) VALUES ('武侠');
INSERT INTO `students`.`tag` (`tag_name`) VALUES ('科幻');
INSERT INTO `students`.`tag` (`tag_name`) VALUES ('男频');
INSERT INTO `students`.`tag` (`tag_name`) VALUES ('女频');
INSERT INTO `students`.`tag` (`tag_name`) VALUES ('漫画');
INSERT INTO `students`.`tag` (`tag_name`) VALUES ('军事');
INSERT INTO `students`.`tag` (`tag_name`) VALUES ('历史');

-- 插入文章数据
INSERT INTO `students`.`article` (`title`) VALUES ('斗破苍穹');
INSERT INTO `students`.`article` (`title`) VALUES ('大奉打更人');
INSERT INTO `students`.`article` (`title`) VALUES ('九重紫');
INSERT INTO `students`.`article` (`title`) VALUES ('回明');
INSERT INTO `students`.`article` (`title`) VALUES ('斗罗大陆');
INSERT INTO `students`.`article` (`title`) VALUES ('庆余年');
INSERT INTO `students`.`article` (`title`) VALUES ('宸汐缘');

-- 插入中间表数据
INSERT INTO `students`.`tag_article` (`tag_id`, `article_id`) VALUES ('1', '1');
INSERT INTO `students`.`tag_article` (`tag_id`, `article_id`) VALUES ('4', '1');
INSERT INTO `students`.`tag_article` (`tag_id`, `article_id`) VALUES ('1', '2');
INSERT INTO `students`.`tag_article` (`tag_id`, `article_id`) VALUES ('4', '2');
INSERT INTO `students`.`tag_article` (`tag_id`, `article_id`) VALUES ('5', '3');
INSERT INTO `students`.`tag_article` (`tag_id`, `article_id`) VALUES ('8', '3');
INSERT INTO `students`.`tag_article` (`tag_id`, `article_id`) VALUES ('1', '5');
INSERT INTO `students`.`tag_article` (`tag_id`, `article_id`) VALUES ('4', '5');
INSERT INTO `students`.`tag_article` (`tag_id`, `article_id`) VALUES ('6', '5');

```

![image-20250201142259035](/img/nestjs-1760441099158-571-image-20250201142259035.png)

![image-20250201142318123](/img/nestjs-1760441099159-316-image-20250201142318123.png)

![image-20250201142340703](/img/nestjs-1760441099159-895-image-20250201142340703.png)

```sql
SELECT t.id tag_id, t.tag_name, a.title
FROM tag_article ta
INNER JOIN article a ON a.id=ta.article_id
INNER JOIN tag t ON t.id=ta.tag_id
```

![image-20250201142940776](/img/nestjs-1760441099160-776-image-20250201142940776.png)

## docker中的快速安装

在这里，我并不会对docker大谈特谈，因为在这里，我们只是把docker当做一个很方便的开发工具进行使用，如果你还不熟悉docker，可以简单理解为，docker就是一个方便帮你安装linux上各种应用的容器即可，不用你去费心的还要去安装linux，或者安装虚拟机，然后费心的配置各种环境，docker直接帮你把应用的整个环境打包好了。

为了让没有接触过docker的同学快速上手，这里也不打算一一去介绍docker的各种繁杂的命令，我们可以直接去安装docker桌面版应用程序，可以让我们直接傻瓜式的直接使用docker。

所以，首先我们去下载安装[docker](https://www.docker.com/)的桌面版的安装程序
![image-20250204131149140](/img/image-20250204131149140.png)

当然，要使用docker，需要特殊的网络环境....
![image-20250204131610043](/img/image-20250204131610043.png)

docker基础理解中最重要的概念就是**镜像（Image）**和**容器（Container）**

你可以这样简单地这样类比：

- **镜像（Image）**= **打包好的应用程序**，就像一个软件的安装包（比如 `.exe` 文件），它包含了应用的代码、依赖、环境配置等。
- **容器（Container）**= **运行中的应用**，就像你从安装包安装并运行的软件，它是镜像的“实例”，可以多个同时运行，互不影响。

所以，我们直接现在docker中下载相应的镜像，然后"安装应用(容器)"即可，比如我们要安装mysql，直接在docker中搜索mysql即可
![image-20250204132032660](/img/image-20250204132032660.png)

Image版本很多，有官方的，也有一些私人的，像mysql这种，我们直接下载官方版本的即可
![image-20250204132208641](/img/image-20250204132208641.png)

下载成功之后，我们就可以运行容器，当然，我们可以进行一些初始化的环境配置

主要是端口映射，以及本地目录映射和环境变量配置
![image-20250204132712153](/img/image-20250204132712153.png)

当然，如果你实在不会使用docker，直接去安装我们后面要用的mysql即可。

## mysql的GUI基本使用

mysql的GUI客户端很多，比如Workbench、Navicat等等，这里我们就选择免费的[Workbench](https://www.mysql.com/products/workbench/)

根据你的系统，选择对应的版本下载即可
![image-20250131150242203](/img/image-20250131150242203.png)

下载会提示你注册登录，可以直接选择跳过即可
![image-20250131150344856](/img/image-20250131150344856.png)

安装完成之后，创建新的数据库链接
![image-20250131150605770](/img/image-20250131150605770.png)
![image-20250131150808812](/img/image-20250131150808812.png)
![image-20250131151220647](/img/image-20250131151220647.png)

接下来其实就是简单的创建库，表等等操作了。
![image-20250131151615539](/img/image-20250131151615539.png)

如果是window系统的话，建议指定一下字符集

接下来创建表，注意双击选择对应的库，进行创建
![image-20250131152029107](/img/image-20250131152029107.png)
![image-20250131152234811](/img/image-20250131152234811.png)
![image-20250131152550167](/img/image-20250131152550167.png)
![image-20250131153524202](/img/image-20250131153524202.png)

其他就不再一一介绍了，用什么样的GUI其实都一样。
