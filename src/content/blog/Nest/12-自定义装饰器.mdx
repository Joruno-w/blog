---
title: 自定义装饰器
description: 自定义装饰器
pubDate: 2025-10-14
toc: true
ogImage: true
category: Nest
---

## 自定义方法装饰器

除了NestJS给我们提供的众多装饰器之外，其实我们还可以自定义装饰器，我们来测试一下，首先还是生成测试项目：

```shell
nest new custom-decorator -g -p npm
```

然后直接通过命令生成自定义装饰器文件：

```typescript
nest g decorator custom --flat
```

文件内就有自动生成的一个函数：

```typescript
import { SetMetadata } from '@nestjs/common'

export const Custom = (...args: string[]) => SetMetadata('custom', args)
```

**Custom**这个自动生成的函数其实就是一个**自定义方法装饰器**，我们稍微改一个名字试试

```typescript
import { SetMetadata } from '@nestjs/common'

export const SetUser = (...args: string[]) => SetMetadata('SetUser', args)
```

然后把这个装饰器用在路由方法之上。

```typescript
@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get('hello1')
  @SetUser('admin', 'user')
  getHello(): string {
    return this.appService.getHello()
  }
}
```

由于是用在Controller上的，要取出SetUser装饰器上的值，我们可以使用**守卫**

创建一个守卫：

```shell
nest g guard custom --flat --no-spec
```

在guard中使用 `reflector` 来取 `metadata`元数据：

```typescript
import {
  CanActivate,
  ExecutionContext,
  Inject,
  Injectable,
} from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { Observable } from 'rxjs'

@Injectable()
export class CustomGuard implements CanActivate {
  @Inject(Reflector)
  private reflector: Reflector

  canActivate(
    context: ExecutionContext
  ): boolean | Promise<boolean> | Observable<boolean> {
    const users = this.reflector.get('SetUser', context.getHandler())
    console.log(users)

    return true
  }
}
```

在Controller上添加上守卫

```typescript
@Get('hello1')
@SetUser('admin', 'user')
@UseGuards(CustomGuard)
getHello(): string {
  return this.appService.getHello();
}
```

当访问路由之后，就会打印通过装饰器设置的值

![image-20250212173620442](/img/nestjs-1760441099117-550-image-20250212173620442.png)

## 自定义参数装饰器

我们可以通过自定义装饰器获取请求中的特定属性：

```typescript
import {
  createParamDecorator,
  ExecutionContext,
  SetMetadata,
} from '@nestjs/common'

export const SetUser = (...args: string[]) => SetMetadata('SetUser', args)

export const GetUser = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    return 'jack'
  }
)
```

在Controller中简单处理一下：

```typescript
@Get('hello2')
getHello2(@GetUser() u: string): string {
  console.log(u);
  return this.appService.getHello();
}
```

返回结果：

![image-20250212173833476](/img/nestjs-1760441099119-958-image-20250212173833476.png)

实际上，`data: string, ctx: ExecutionContext`都是有用的。

`data` 很明显就是传入的参数，而 `ExecutionContext` 前面用过，可以取出 `request`、`response` 对象。

比如我们写成下面的样子：

```typescript
export const GetUser = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest()
    console.log(request)
    console.log(data)
    return request.query[data]
  }
)
```

在Controller中进行处理

```typescript
@Get('hello2')
getHello2(@GetUser('name') u: string): string {
  console.log('---', u);
  return this.appService.getHello();
}
```

页面访问：

![image-20250212175527647](/img/nestjs-1760441099119-504-image-20250212175527647.png)

现在看一下打印信息，就知道data和ExecutionContext的作用了

![image-20250212174923332](/img/nestjs-1760441099119-618-image-20250212174923332.png)

很明显，data其实就是装饰器中声明的参数名，而且既然我们可以获取request对象，那么我们完全可以复刻NestJS自带的一些参数装饰器，比如`@Param`、`@Query`、`@Headers`等等

### 自定义的`MyHeaders`

```typescript
export const MyHeaders = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request: Request = ctx.switchToHttp().getRequest()
    return data ? request.headers[data.toLowerCase()] : request.headers
  }
)
```

Controller中使用和`@Headers`用法一模一样

```typescript
@Get('hello3')
getHello3(@Headers('host') header1, @MyHeaders('host') header2): string {
  console.log(header1);
  console.log(header2);
  return this.appService.getHello();
}
```

### 自定义`MyQuery`

```typescript
export const MyQuery = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request: Request = ctx.switchToHttp().getRequest()
    return request.query[data]
  }
)
```

Controller中使用和`@Query`用法一模一样

```typescript
@Get('hello4')
getHello4(
  @Query('username') username: string,
  @MyQuery('age') age: number,
): string {
  console.log(username);
  console.log(age);
  return this.appService.getHello();
}
```

![image-20250212180036943](/img/nestjs-1760441099120-465-image-20250212180036943.png)

![image-20250212180100326](/img/nestjs-1760441099120-150-image-20250212180100326.png)

### 自定义`MyParam`

```typescript
export const MyParam = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request: Request = ctx.switchToHttp().getRequest()
    return data ? request.params[data] : request.params
  }
)
```

Controller上访问

```typescript
@Get(':username')
getHello5(
  @Param('username') username1: string,
  @MyParam('username') username2: string,
): string {
  console.log(username1);
  console.log(username2);
  return this.appService.getHello();
}
```

![image-20250212180558917](/img/nestjs-1760441099121-539-image-20250212180558917.png)

![image-20250212180624459](/img/nestjs-1760441099122-355-image-20250212180624459.png)

## 装饰器合并

如果我们觉得装饰太多，也可以自定义装饰器将众多装饰器合并为一个，比如之前的装饰器：

![image-20250213120336654](/img/nestjs-1760441099123-649-image-20250213120336654.png)

我们可以使用**applyDecorators**组合多个装饰器：

```typescript
export function MyCombinedDecorator(path: string, ...user: string[]) {
  return applyDecorators(Get(path), SetUser(...user), UseGuards(CustomGuard))
}
```

然后用这一个装饰器，去替换掉之前的三个装饰器就行了：

```typescript
// @Get('hello1')
// @SetUser('admin', 'user')
// @UseGuards(CustomGuard)
@MyCombinedDecorator('hello1', 'admin', 'user')
getHello(): string {
  return this.appService.getHello();
}
```

## 自定义 class 装饰器

类装饰器需要结合着**applyDecorators**一起来使用：

```typescript
export function MyController(path: string, metaData: string) {
  return applyDecorators(Controller(path), SetMetadata('MyClass', metaData))
}
```

我们直接在AppController上使用：

![image-20250213122051718](/img/nestjs-1760441099124-640-image-20250213122051718.png)

由于在`CustomGuard`上我们有拦截，所以为了获取`MyController`上的`metaData`数据，我们可以在`CustomGuard`稍微处理一下：

```diff
@Injectable()
export class CustomGuard implements CanActivate {
  @Inject(Reflector)
  private reflector: Reflector;
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
+    const metaData = this.reflector.get('MyClass', context.getClass());
+    console.log(metaData);

    const users = this.reflector.get('SetUser', context.getHandler());
    console.log(users);
    return true;
  }
}
```
