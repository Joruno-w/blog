---
title: 快速上手Nest Cli
description: 快速上手Nest Cli
pubDate: 2025-10-14
toc: true
ogImage: true
category: Nest
---

## Nest CLI的安装与命令

执行一下命令即可将Nest CLI安装为全局工具

```shell
npm i -g @nestjs/cli
```

安装完成之后，执行`nest -h`命令，结果如图：

![image-20250109150839292](/img/nestjs-1760441098921-962-image-20250109150839292.png)

Nest提供了非常丰富的命令：

- nest new：用于创建项目
- nest build：用于构建生成环境代码
- nest start：用于启动本地开发服务
- nest info：用于查看当前项目中的Nest包信息
- nest add：用于添加官方插件或者第三方模块
- nest generate：用于生成各种模块代码，比如Module、Controller、Service、Pipe、Middleware等

同时，命令也支持别名，比如`nest n`、`nest i`、`nest g`

## 创建项目

创建项目可以直接使用 `nest new` 命令，当然我们也可以通过`-h`查看相关参数

```shell
nest new -h
```

![image-20250109151705419](/img/nestjs-1760441098923-615-image-20250109151705419.png)

- `--skip-git`和`--skip-install`：用于跳过Git初始化和npm包安装步骤
- `--package-manager`：指定使用的包管理器(npm/yarn/**pnpm**)
- `--language`：使用TS还是JS进行编写代码，默认使用TS
- `--collection`：用于指定工作流集合，默认是`@nestjs/schematics`，用于创建模块，控制器，服务等等，与`nest generate`命令相关。通常默认值即可。
- `--strict`：用于指定TS是否以严格模式运行

直接执行`nest n [工程名]`即可帮你创建项目，不过会提示你使用什么包管理器

![image-20250109152421303](/img/nestjs-1760441098925-351-image-20250109152421303.png)

当然，也可以加上参数

![image-20250109152618122](/img/nestjs-1760441098925-14-image-20250109152618122.png)

CLI直接创建的项目模板：

![image-20250109153900021](/img/nestjs-1760441098927-381-image-20250109153900021.png)

我们也可以使用`nest generate`单独创建项目需要的内容，比如模块，控制器，服务等等

## 生成指定的代码片段

执行`nest generate -h`命令，可以查看相关内容

![image-20250109154145396](/img/nestjs-1760441098928-353-image-20250109154145396.png)

你可以通过下面的命令，逐个生成Controller、Service或者Module

```typescript
nest g controller 控制器名称
```

![image-20250109154710756](/img/nestjs-1760441098930-866-image-20250109154710756.png)

```shell
nest g service 服务名称
```

![image-20250109154828012](/img/nestjs-1760441098931-863-image-20250109154828012.png)

```typescript
nest g module 模块名称
```

![image-20250109155054559](/img/nestjs-1760441098932-636-image-20250109155054559.png)

其实，module，service和controller是有关系，只是这其中的关系我们后面再慢慢解释，这涉及到后端架构方面的处理，反正无论如何这几个我们都要创建，那一个个去处理太麻烦，所以我们可以直接使用`nest generate resource`命令一键生成后端需要的`CRUD`模板代码

```shell
nest g resource person
```

注意需要选择REST风格的API

![image-20250109155426450](/img/nestjs-1760441098933-247-image-20250109155426450.png)![image-20250109155646068](/img/nestjs-1760441098934-775-image-20250109155646068.png)![image-20250109155729674](/img/nestjs-1760441098934-519-image-20250109155729674.png)

其中dto和entity是CRUD相关需要的代码，我们这里暂时不需要理会他们，后面我们会慢慢讲解

![image-20250109161800737](/img/nestjs-1760441098937-42-image-20250109161800737.png)

`.spec.ts`是单元测试文件，我们可以在创建的时候，通过参数`--no-spec`参数表明不生成测试文件，比如：

```typescript
nest g resource order --no-spec
```

![image-20250109162144982](/img/nestjs-1760441098937-672-image-20250109162144982.png)

## 一些格式报错问题

工程创建好之后，有些代码会报错。

![image-20250109161330370](/img/nestjs-1760441098936-526-image-20250109161330370.png)

![image-20250109161357627](/img/nestjs-1760441098936-202-image-20250109161357627.png)

其实这并不是错误，而是eslint与prettier配置的问题，如果你不想这些红色波浪线错误困扰你，可以直接配置`.eslintrc.js`屏蔽掉这些错误：

```typescript
module.exports = {
  // ......
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'no-unused-vars': 'off',
    '@typescript-eslint/no-unused-vars': 'off',
    'prettier/prettier': [
      'warn',
      {
        endOfLine: 'auto',
      },
    ],
  },
}
```

## 构建应用

可以通过`nest build`命令来构建应用

默认情况下，Nest使用tsc进行编译，直接运行`nest build`命令相关如下：

![image-20250109162535909](/img/nestjs-1760441098938-843-image-20250109162535909.png)

如果我们希望编译并打包，可以直接切换使用`webpack`进行打包，只需要使用参数 `-b webpack`

当然，相关的参数，一样可以使用`nest build -h`来进行查看

```typescript
nest build -b webpack
```

![image-20250109162744925](/img/nestjs-1760441098938-422-image-20250109162744925.png)

## nest-cli.json

每次执行都需要加上一些参数，这样太麻烦了，nest给我们提供了`nest-cli.json`配置文件，我们可以在这个配置文件中，直接配置上我们经常需要使用的参数，比如：

```typescript
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "generateOptions": {
    "spec": false, // 是否生成测试文件
    "flat": false // 是否扁平化直接生成文件在src目录下(默认为true，会生成对应的目录结构)
  },
  "compilerOptions": {
    "deleteOutDir": true, // 是否删除输出目录
    "webpack": true // 是否使用webpack
  }
}
```

## 简单测试

在main.ts文件中修改端口号，比如为8088

```typescript
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  await app.listen(8088)
}
bootstrap()
```

为了返回数据方便，先定义一个实体类，比如`admin.entity.ts`

```typescript
export class Admin {
  constructor(
    private id: string,
    private name: string,
    private password: string
  ) {
    this.id = id
    this.name = name
    this.password = password
  }
}
```

controller中处理

```typescript
import { Controller, Get, Param } from '@nestjs/common'
import { AppService } from './app.service'
import { Admin } from './admin.entity'

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getAll(): Admin[] {
    return this.appService.getAll()
  }

  @Get(':id')
  getOne(@Param('id') id: string): Admin {
    return this.appService.getOne(id)
  }
}
```

service中处理

```typescript
import { Injectable } from '@nestjs/common'
import { Admin } from './admin.entity'

@Injectable()
export class AppService {
  getAll(): Admin[] {
    return [
      new Admin('1', 'John Doe', 'password'),
      new Admin('2', 'Jane Doe', 'password'),
      new Admin('3', 'Jim Doe', 'password'),
    ]
  }

  getOne(id: string): Admin {
    return new Admin('1', 'John Doe', 'password')
  }
}
```

通过命令`nest start -w`启动后端服务

我们可以直接使用`Apifox`，或者`postman`直接测试端口

![image-20250110161457740](/img/nestjs-1760441098939-885-image-20250110161457740.png)
