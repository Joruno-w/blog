---
title: LangChain中创建Agent
description: LangChain中创建Agent
pubDate: 2025-09-28
toc: true
ogImage: true
category: Langchain
---

## LangChain Hub

LangChain Hub 是一个托管 Prompt 与 Chain 配置的集中仓库（可以理解成 Hugging Face Hub 的“提示词版”）。

它允许开发者：

- 上传 / 分享 自己的 prompt、chain 配置；
- 下游用户可以直接通过一个 key (`author/name`) 拉取使用；
- 便于复用、标准化，而不是大家都在项目里复制粘贴 prompt 字符串。

官方定位：“Prompt templates hosting and sharing service”。

核心 API 就两个：

**`pull(identifier: string)`**：从 Hub 拉取指定资源（prompt 或 chain）。

- 参数 `identifier` 的形式通常是：
  - `"hwchase17/react"`
  - `"hwchase17/openai-tools-agent"`
  - `"org_name/custom_prompt"`
- 返回值取决于资源类型：
  - 如果是 prompt，就返回 `PromptTemplate` 或 `ChatPromptTemplate` 对象；
  - 如果是 chain，就返回 chain runnable。

`push(...)`：把本地的 prompt / chain 上传到 Hub（需配置账户权限），JS/TS 里用得少，更多是官方/团队场景。

得到的提示词：

```js
Answer the following questions as best you can. You have access to the following tools:

{tools}

Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question

Begin!

Question: {input}
Thought:{agent_scratchpad}
```

- Question：自动填充成用户输入；
- Thought：模型写下推理思路（“我需要先查天气，然后算…”）；（CoT：Chain of Thought）
- Action：必须严格写成工具名之一（`[{tool_names}]` 会替换成 `weather, calculator` 之类）；
- Action Input：传给工具的参数（字符串）；
- Observation：执行工具的返回结果；
- 循环：Thought → Action → Action Input → Observation 可以重复多次；
- Final Answer：最终答案，直接写给用户。

这就是 ReAct 循环（Reasoning + Acting）

```
Begin!

Question: {input}
Thought:{agent_scratchpad}
```

- **`{input}`**：用户真实提问，比如“北京今天的天气如何？”；

- **`{agent_scratchpad}`**：ReAct 的关键变量，用来记录之前所有的 Action/Observation 历史。
  - 第一次调用时是空；

  - 之后每轮会把上一轮的 Action/Observation 填进去，再交给模型继续思考。

## Tools

前面介绍的模型携带 Tools：

```js
const modelWithTool = new ChatOpenAI({
  model: 'gpt-3.5-turbo-1106',
  apiKey: process.env.API_KEY,
  temperature: 0,
}).withConfig({
  tools: [
    {
      type: 'function',
      function: {
        name: 'getCurrentWeather',
        description: '获取指定城市当前天气',
        parameters: getCurrentWeatherJsonSchema,
      },
    },
  ],
})
```

这是 OpenAI API 的原生 Function Calling / Tool Calling 配置。在 底层 LLM 请求里，直接把工具符合 OpenAI 规范的 schema **传给模型**。特点：

- 完全贴近 OpenAI 官方的 `tools: [...]` 格式（`type: "function"` + JSON Schema）。
- 模型生成的 `tool_calls` 会自动遵守 schema；
- 这是模型原生能力，不需要 ReAct prompt。

这里要使用的 Tool 稍微有些不同，需要一个能被 Agent 消费的 Tool。

在 LangChain.js 中，提供了一个 Tool 工具，能够生成给 Agent 消费的 Tool 工具：

```js
import { tool } from "@langchain/core/tools";
tool(方法(具体的业务逻辑)，{
	name: "xxx",
  description: "xxx",
  schema: "xxx"
})
```

示例：

```js
import { tool } from '@langchain/core/tools'
import { z } from 'zod'

const weatherTool = tool(
  async (city) => `${city}：多云转晴，28℃ / 20℃（示例数据）`,
  {
    name: 'weather',
    description: '查询城市天气。输入城市名。',
    schema: z.string(),
  }
)
```

上例中得到的 weatherTool 是一个符合 LangChain Tool 接口的对象，可被 AgentExecutor/ createReactAgent/ createToolCallingAgent 直接使用。

## createReactAgent

LangChain.js 中提供方法，用于**创建基于 ReAct 提示法的 Agent**。方法签名：

```js
createReactAgent(params)
```

必填 params 参数：

- `llm`：任一兼容的聊天/文本 LLM。
- `tools`：工具列表（结构化工具）。
- `prompt`：ReAct 模板（推荐直接从 Hub 拉 `hwchase17/react`）。这个 prompt 决定了该 agent 的输入变量集合。

返回值：返回的是一个 runnable，每次调用只产出两类结果之一：

- `AgentAction`：表示“去调用某个工具”的决策。包含三要素：
  - `tool`（工具名）
  - `toolInput`（传给工具的输入，字符串或对象）
  - `log`（可读的思考/轨迹文本）
- `AgentFinish`：表示“本回合已经得到最终答案”。包含：
  - `returnValues`（一个对象，通常至少有 `output` 字段）
  - `log`（最终总结/轨迹）

打印出来的 agent，大致是如下的形式：

```
RunnableSequence (name: "ReactAgent")
  ├─ first:  RunnableAssign( mapper = RunnableMap(...) )
  ├─ middle: [ PromptTemplate(...), ChatOpenAI(...) ]
  └─ last:   ReActSingleInputOutputParser(toolNames=[...])

===> 输入 → Assign预处理 → 模板渲染 → LLM补全 → ReAct输出解析 → (AgentAction | AgentFinish)
```

- **`RunnableSequence`**：LCEL 的“管道”。把多个 runnable 依次串起来。
  - first：把原始输入整理成 Prompt 需要的变量。
  - middle：
    - 第 1 项：从 Hub 拉下来的 ReAct 模板
    - 第 2 项：LLM 调用
  - last：ReAct 专用输出解析器。它会：
    - 检查模型的文本是否遵守规范（有 `Action:`、`Action Input:`、`Final Answer:` 等）。
    - 如果检测到 `Final Answer:` ：产出 **`AgentFinish`**（结束）。
    - 否则解析出 `Action` + `Action Input` ：产出 **`AgentAction`**

- **`singleAction: true`**：这个 Agent 每次只产出一个结果：
  - 要么一个工具动作（`AgentAction`）
  - 要么终止（`AgentFinish`）

## AgentExecutor

AgentExecutor，顾名思义，就是 agent 执行器，它把你已经构造好的 agent 和 tools 结合起来，负责外层的 ReAct 式决策循环：反复“让 agent 规划一步 → 调工具 → 回填观察 → 再问 agent”，直到结束。

具体的运行过程：

1. 调用 agent：agent 会返回 **`AgentAction`**（要调哪个工具+参数）或 **`AgentFinish`**（结束）
2. 执行工具：当拿到 `AgentAction` 时，AgentExecutor 根据 `action.tool` 找到对应 tool，校验 `toolInput`，执行并得到 observation。
3. 记录中间步骤：把 `{ action, observation }` 追加成一条 AgentStep，同时把它格式化进 `agent_scratchpad`，供下一轮给 agent 使用。
4. 判断是否继续：如果 agent 返回 **`AgentFinish`**，或到达最大迭代次数，则停止并产出最终结果。官方提供了一个 `shouldContinueGetter()` 用来判断是否继续（基于已执行轮数）。

对应的配置项、方法等可以参阅 [这里](https://v03.api.js.langchain.com/classes/langchain.agents.AgentExecutor.html)。
