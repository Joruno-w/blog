---
title: 状态管理介绍
description: 状态管理介绍
pubDate: 2025-10-10
toc: true
ogImage: true
category: React Native
---

在目前前端的组件化开发风潮中，无论是 _PC_ 端还是移动端，对于组件化来讲有一个非常重要的就是状态管理。要理解什么状态管理，首先就要理解什么是状态。

实际上，状态的概念非常简单，就是每个组件自身可以维护一些数据。而由于组件与组件之间存在一些关系（例如父子关系、兄弟关系），这就避免不了组件之间要进行数据的传递，这也就是所谓的组件状态管理出现的背景。

![image-20220627103352425](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-06-27-023352.png)

如果使用传统的 _porps_ 或者自定义事件的形式来传递组件的数据，就会显得非常的繁琐，一个组件状态更新，需要一层一层传递到根组件，再由根组件一层一层往下传递。这样一个应用的组件层数嵌套得越深，工作量就会变得越大。

在这样的背景下，专门用于状态管理的库就出现了。

![image-20220627105559707](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-06-27-025600.png)

状态管理库的核心思想很简单，专门拿一个 _store_ 的仓库来管理所有组件的状态，假如一个组件状态更新后，同步更新仓库中的状态，这样另一个组件再获取最新的状态时，也不用向之前那样层层传递，直接从仓库获取最近的状态即可。

目前，市面上比较流行的状态管理库有：

- _Flux_
- _Vuex_
- _Redux_
- _Mobx_

### _Flux_

_2013_ 年，_Facebook_ 亮出 _React_ 的时候，也跟着带出了 _Flux_。_Facebook_ 认为两者相辅相成，结合在一起才能构建大型的 _JavaScript_ 应用。

_Flux_ 的组成：

- _View_: 视图层
- _Action_: 动作，即数据改变的消息对象（可通过事件触发、测试用例触发等）
  - _Store_ 的改变只能通过 _Action_
  - 具体 _Action_ 的处理逻辑一般放在 _Store_ 里
  - _Action_ 对象包含 _type_（类型）与 _payload_（传递参数）
  - _Action_ 仅仅是改变 _Store_ 的一个动作，一般包含该动作的类型、传递的数据
- _Dispatcher_: 派发器，接收 _Actions_，发给所有的 _Store_。
- _Store_: 数据层，存放应用状态与更新状态的方法，一旦发生变动，就提醒 _Views_ 更新页面

![image-20220627105617920](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-06-27-025618.png)

_Flux_ 的特点：

- 单向数据流。视图事件或者外部测试用例发出 _Action_，经由 _Dispatcher_ 派发给 _Store_，_Store_ 会触发相应的方法更新数据、更新视图
- _Store_ 可以有多个
- _Store_ 不仅存放数据，还封装了处理数据的方法

### _Vuex_

_Vuex_ 是 _Vue_ 官方推出的状态管理库。

_Vuex_ 的核心概念：

- _Store_: _Vuex_ 采用单一状态树，每个应用仅有一个 _Store_ 实例，在该实例下包含了 _state、actions、mutations、getters、modules_。
- _State_: _Vuex_ 为单一数据源。可以通过 _mapState_ 辅助函数将 _state_ 作为计算属性访问，或者将通过 _Store_ 将 _state_ 注入全局之后使用 _this.$store.state_ 访问。_State_ 更新视图是通过 _vue_ 的双向绑定机制实现的。
- _Getter_: _Getter_ 的作用与 _filters_ 有一些相似，可以将 _State_ 进行过滤后输出。
- _Mutation_: _Mutaion_ 是 _vuex_ 中改变 _State_ 的唯一途径（严格模式下），并且只能是同步操作。_Vuex_ 中通过 _store.commit( )_ 调用 _Mutation_。
- _Action_: 一些对 _State_ 的异步操作可以放在 _Action_ 中，并通过在 _Action_ 提交 _Mutaion_ 变更状态。_Action_ 通过 _store.dispatch( )_ 方法触发。可以通过 _mapActions_ 辅助函数将 _vue_ 组件的 _methods_ 映射成 _store.dispatch_ 调用（需要先在根节点注入 _store_）。
- _Module_: 当 _Store_ 对象过于庞大时，可根据具体的业务需求分为多个 _Module_，每个 _Module_ 都具有自己的 _state 、mutation 、action 、getter_。

<img
  src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-06-27-025636.png"
  alt="image-20220627105636282"
  style="zoom:50%;"
/>

_Vuex_ 的特点：

- 单向数据流。_View_ 通过 _store.dispatch( )_ 调用 _Action_，在 _Action_ 执行完异步操作之后通过 _store.commit( )_ 调用 _Mutation_ 更新 _State_，通过 _vue_ 的响应式机制进行视图更新。
- 单一数据源，和 _Redux_ 一样全局只有一个 _Store_ 实例。
- 可直接对 _State_ 进行修改。

### _Redux_

作为一款针对 _JavaScript_ 应用的可预测状态管理容器库，由 _Dan Abramov_ 在 _2015_ 年创建的 _Redux_ 在创建之初曾受到 _Flux_ 架构以及函数式 _Elm_ 的启发。后来，随着 _Dan Abramov_ 加盟 _Facebook_，_Redux_ 最终成为 _Facebook_ 旗下的一个子项目。_Redux_ 之所以被广泛接受，是因为 _Redux_ 融合了各家技术于一身，不但简化了 _Flux_ 的流程与开发方式，还引入了一些优秀的设计理念。

作为一个应用状态管理库，_Redux_ 和 _Flux_ 有很多相似的地方。不同之处在于，_Flux_ 可以有很多个改变应用状态的 _Store_，并可以通过事件来触发状态的变化，组件可以通过订阅这些事件来和当前状态保持同步。

在 _Redux_ 中，则并没有 _Dispatcher_（分发器）的概念，_Redux_ 使用一个单独的常量状态树来保存整个应用的状态，并且这个对象是不能直接被改变的。如果某些数据发生改变，那么就会创建出一个新的对象。

由于 _Redux_ 是在 _Flux_ 的基础上扩展出的一种单向数据流的实现，所以数据的流向、变化都能得到清晰的控制，并且能很好地划分业务逻辑和视图逻辑。

_Redux_ 的组成：

- _Store_: 存储应用 _state_ 以及用于触发 _state_ 更新的 _dispatch_ 方法等，整个应用仅有单一的 _Store_
- _Store_ 中提供了几个 _API_:
  - _store.getState( )_: 获取当前 _state_
  - _store.dispatch(action)_: 用于 _View_ 发出 _Action_
  - _store.subscribe(listener)_: 设置监听函数，一旦 _state_ 变化则执行该函数（若把视图更新函数作为 _listener_ 传入，则可触发视图自动渲染）。
- _Action_: 同 _Flux_，_Action_ 是用于更新 _state_ 的消息对象，由 _View_ 发出。有专门生成 _Action_ 的 _Action Creator_
- _Reducer_: 是一个用于改变 _state_ 的纯函数（对于相同的参数返回相同的返回结果，不修改参数，不依赖外部变量），即通过应用状态与 _Action_ 推导出新的 _state_: _(previousState, action) => newState_。_Reducer_ 返回一个新的 _state_

![image-20220627110106329](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-06-27-030106.png)

_Redux_ 的特点：

- 单向数据流。_View_ 发出 _Action(store.dispatch(action))_，_Store_ 调用 _Reducer_ 计算出新的 _state_，若 _state_ 产生变化，则调用监听函数重新渲染 _View_ _(store.subscribe(render))_。
- 单一数据源，只有一个 _Store_。
- _state_ 是只读的，每次状态更新之后只能返回一个新的 _state_。
- 没有 _Dispatcher_，而是在 _Store_ 中集成了 _dispatch_ 方法，_store.dispatch( )_ 是 _View_ 发出 _Action_ 的唯一途径。

### _Mobx_

作为一个应用状态管理库，_Redux_ 被广泛用于复杂的大型应用中，在很多大型 _Web_ 前端应用中都可以看到它的身影。不过除了 _Redux_，社区里近年来还有另一产品呼声很高，那就是 _Mobx_。

_MobX_ 是由 _Mendix、Coinbase_ 和 _Facebook_ 开源的状态管理框架。MobX 背后的哲学是:

> 任何源自应用状态的东西都应该自动地获得。

意思就是，当状态改变时，所有应用到状态的地方都会自动更新。它通过响应式函数编程来实现状态的存储和管理。**受到面向对象编程和响应式编程的影响，_Mobx_ 可以将状态包装成可观察对象，通过观察和修改对象的状态进而实现视图的更新。**

这样一个功能强大，上手非常容易的状态管理工具。就连 _Redux_ 的作者也曾经向大家推荐过它，在不少情况下你的确可以使用 _Mobx_ 来替代掉 _Redux_。

_MobX_ 的核心概念：

- _State_: 驱动应用的数据
- _Computed values_: 计算值。如果你想创建一个基于当前状态的值时，请使用 _computed_
- _Reactions_: 反应，当状态改变时自动发生
- _Actions_: 动作，用于改变 _State_
- 依赖收集（_autoRun_）: _MobX_ 中的数据以来基于观察者模式，通过 _autoRun_ 方法添加观察者

![image-20220627110125184](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-06-27-030125.png)

_MobX_ 的特点：

- 数据流流动不自然，只有用到的数据才会引发绑定，局部精确更新（细粒度控制）
- 没有时间回溯能力，因为数据只有一份引用
- 基于面向对象
- 往往是多个 _Store_
- 代码侵入性小
- 简单可扩展
- 大型项目使用 _MobX_ 会使得代码难以维护

最后总结一下：

- _Flux 、Redux 、Vuex_ 均为单向数据流。
- _Redux_ 和 _Vuex_ 是基于 _Flux_ 的，_Redux_ 较为泛用，_Vuex_ 只能用于 _vue_。
- _Flux_ 与 _MobX_ 可以有多个 _Store_，_Redux、Vuex_ 全局仅有一个 _Store_（单状态树）。
- _Redux、Vuex_ 适用于大型项目的状态管理，_MobX_ 在大型项目中应用会使代码可维护性变差。
- _Redux_ 中引入了中间件，主要解决异步带来的副作用，可通过约定完成许多复杂工作。
- _MobX_ 是状态管理库中代码侵入性最小的之一，具有细粒度控制、简单可扩展等优势，但是没有时间回溯能力，一般适合应用于中小型项目中。
