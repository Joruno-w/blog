---
title: React Navigation简介
description: React Navigation简介
pubDate: 2025-10-10
toc: true
ogImage: true
category: React Native
---

从本章起我们开始学习 _RN_ 社区相关的生态库。_RN_ 的社区生态相当丰富，很多东西官方没有提供，但是在社区已经有了很好的解决方案。

这里首当其冲要介绍的就是 _React Navigation_，这是一个诞生于社区的 _RN_ 导航库。

本小节将介绍如下的内容：

- 什么是 _React Navigation_
- _React Navigation_ 安装

## 什么是 _React Navigation_

_React Navigation_ 的诞生，源于 _RN_ 社区对基于 _Javascript_ 的可扩展且使用简单的导航解决方案的需求。

_React Navigation_ 是 _Facebook、Expo_ 和 _React_ 社区的开发者们合作的结果：它取代并改进了 _RN_ 生态系统中的多个导航库，其中包括 _Ex-Navigation_、_RN_ 官方的 _Navigator_ 和 _NavigationExperimental_ 组件。

学习 _React Navigation_，可以阅读官方的文档：*https://reactnavigation.org/*

![image-20220624100945915](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-06-24-020946.png)

**_React Navigation_ 特点**

在 _React Navigation_ 中，内置了 _3_ 种导航器，可以帮助我们实现页面之间的跳转。

主要包含以下 _3_ 种导航器：

- _StackNavigator_：一次只渲染一个页面，并提供页面之间跳转的方法。当打开一个新的页面时，它被放置在堆栈的顶部。简单来讲，就是普通页面跳，可传递参数。

- _TabNavigator_：渲染一个选项卡，类似底部导航栏，让用户可以在同一屏中进行几个页面之间切换。

- _DrawerNavigator_：提供一个从屏幕左侧滑入的抽屉。

## _React Navigation_ 安装

接下来，要使用 _React Navigation_ 首先第一步肯定是需要安装这个库。

关于安装，请参阅：*https://reactnavigation.org/docs/getting-started*

首先第一步，在项目中输入如下的命令：

```js
npm install @react-navigation/native
```

安装完成后，根据官方文档的描述，还需要安装 _react-native-screens_ 以及 _react-native-safe-area-context_ 这两个依赖库，因为我们是使用 _expo_ 搭建的项目，所以可以输入如下的命令：

```js
expo install react-native-screens react-native-safe-area-context
```

具体操作如下图：

<img
  src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-06-24-021005.png"
  alt="image-20220624101005788"
  style="zoom:50%;"
/>

> 注：如果安装途中遇到任何网络超时问题，请自行解决科学上网问题

## 快速体验 _React Navigation_

安装完成后，我们就可以来书写一个简单的 _demo_ 来体验下 _React Navigation_。

由于新版本的 _React Navigation_ 已经将导航器独立成了一个单独的包，因此我们首先需要安装要用到的导航器。

```js
npm install @react-navigation/native-stack
```

具体操作如下图所示：

<img
  src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-06-24-021028.png"
  alt="image-20220624101027799"
  style="zoom:50%;"
/>

接下来书写如下的测试代码：

```js
// In App.js in a new project

import * as React from 'react'
import { View, Text, Button } from 'react-native'
import { NavigationContainer } from '@react-navigation/native'
import { createNativeStackNavigator } from '@react-navigation/native-stack'

function HomeScreen({ navigation }) {
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Text>Home Screen</Text>
      <Button
        title="Go to Details"
        onPress={() => navigation.navigate('Details')}
      />
    </View>
  )
}

function DetailsScreen({ navigation }) {
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Text>Details Screen</Text>
      <Button
        title="Go to Details1"
        onPress={() => navigation.push('Details')}
      />
      <Button
        title="Go to Details2"
        onPress={() => navigation.navigate('Details')}
      />
      <Button title="Go to Home" onPress={() => navigation.navigate('Home')} />
      <Button title="Go back" onPress={() => navigation.goBack()} />
    </View>
  )
}

const Stack = createNativeStackNavigator()

function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen
          name="Home"
          component={HomeScreen}
          options={{ title: 'Overview' }}
        />
        <Stack.Screen name="Details" component={DetailsScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  )
}

export default App
```

在上面的代码中，我们首先创建了 _HomeScreen_ 和 _DetailsScreen_ 这两个组件，也就是我们的两个屏幕。

接下来调用 _createNativeStackNavigator_ 方法创建了一个 _Stack_ 导航的实例对象，之后通过如下的结构嵌套多个屏幕：

```js
<NavigationContainer>
  <Stack.Navigator>
    <Stack.Screen
      name="Home"
      component={HomeScreen}
      options={{ title: 'Overview' }}
    />
    <Stack.Screen name="Details" component={DetailsScreen} />
  </Stack.Navigator>
</NavigationContainer>
```

可以看到，_Stack.Screen_ 就代表一屏，因为我们现在有两屏，所以一共有两个 _Stack.Screen_。

在屏幕组件中，会自动传入当前的导航器实例，通过解构拿到这个导航器实例，上面常用的方法有：

- _navigate_：导航方法，要导航到哪一屏，如果本身已经处于该屏，则不进行操作
- _push_：以栈的形式往路由栈里面压入新的一屏，即使当前已处于该屏，也会重复压入新的一屏
- _goBack_：返回上一屏，简单来讲就是栈顶那一屏出栈，回到栈顶的倒数第二屏
