---
title: Portals
description: Portals
pubDate: 2025-10-11
toc: true
ogImage: true
category: React
---

# 6. _Portals_

_Portals_ 被翻译成传送门，它要做的事情实际上也确实和传送门很相似，根据官方的解释：

> _Portal_ 提供了一种将子节点渲染到存在于父组件以外的 _DOM_ 节点的优秀的方案。

其语法为：

```js
ReactDOM.createPortal(child, container)
```

第一个参数（_child_）是任何可渲染的 _React_ 子元素，第二个参数（_container_）是一个 _DOM_ 元素。

学习一个知识我们仍然是应该从以下 _2_ 个点着手：

- 何时用？
- 如何用？

## 什么场景下需要使用 _Portals_

首先我们来看一个场景，如下：

```js
// App.jsx
import { useState } from 'react'
import Modal from './components/Modal'
function App() {
  const [isShow, setIsShow] = useState(false)
  return (
    <div>
      <h1>App组件</h1>
      <button onClick={() => setIsShow(!isShow)}>显示/隐藏</button>
      {isShow ? <Modal /> : null}
    </div>
  )
}

export default App
```

```js
function Modal() {
  return (
    <div
      style={{
        width: '450px',
        height: '250px',
        border: '1px solid',
        position: 'absolute',
        left: 'calc(50% - 225px)',
        top: 'calc(50% - 125px)',
        textAlign: 'center',
        lineHeight: '250px',
      }}
    >
      模态框
    </div>
  )
}

export default Modal
```

在上面的示例中，_Modal_ 是一个模态框，在 _App_ 根组件中能够控制该模态框组件是否显示。

上面的示例，功能倒是没有什么问题，但是从最终渲染出来的 _html_ 结构上来讲，将整个模态框都放在 _root_ 这个 _div_ 中不是那么合适，我们生成的 _html_ 结构上，这个模态框能够渲染到 _modal_ 那个 _div_ 里面。

![image-20221208144840081](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-12-08-064840.png)

并且一旦父组件上面设置了额外的样式，都会影响这个子组件的渲染，例如：

```js
<div
  style={{
    position: 'relative',
  }}
>
  <h1>App组件</h1>
  <button onClick={() => setIsShow(!isShow)}>显示/隐藏</button>
  {isShow ? <Modal /> : null}
</div>
```

我们在 _App_ 组件中添加一条相对定位的样式，此时我们就会发现由于 _Modal_ 是放在整个 _root_ 元素里面的，模态框的位置就会收到影响。

因此，在这种时候，我们就可以使用 _Portals_ 来解决这个问题。

## 如何使用 _Portals_

_Portals_ 的使用方式也非常简单，只需要使用 _createPortal_ 方法来指定渲染到哪个元素中即可。需要注意的是这是和 _React_ 渲染相关的，所以 _createPortal_ 方法来自于 _react-dom_ 这个库。

```js
import { createPortal } from 'react-dom'

function Modal() {
  return createPortal(
    <div
      style={{
        width: '450px',
        height: '250px',
        border: '1px solid',
        position: 'absolute',
        left: 'calc(50% - 225px)',
        top: 'calc(50% - 125px)',
        textAlign: 'center',
        lineHeight: '250px',
      }}
    >
      模态框
    </div>,
    document.getElementById('modal')
  )
}

export default Modal
```

在上面的代码中，我们将要渲染的视图作为 _createPortal_ 方法的第一个参数，而第二个参数用于指定要渲染到哪个 _DOM_ 元素中。

![image-20221208144859727](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-12-08-064859.png)

可以看到，这一次模态框就被渲染到了 _id_ 为 _modal_ 的 _div_ 中。并且在 _root_ 中所设置的样式都不会影响到模态框的显示。

> 其实根据官方的介绍，_Portals_ 的典型用例是当父组件有 _overflow: hidden_ 或 _z-index_ 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框。

## 通过 _Portal_ 进行事件冒泡

最后需要注意一下的就是使用 _Portal_ 所渲染的元素在触发事件时的冒泡问题。

以上面的例子为例，看上去模态框已经渲染到了 _modal_ 这个元素里面，但是在 _React_ 中事件冒泡是按照组件结构来进行冒泡的，我们可以看到即使模态框已经渲染到了 _modal_ 里面，但是在组件树中模态框组件仍然是在根组件中。

![image-20221208144916048](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-12-08-064916.png)

我们也可以书写一个例子来验证一下，例如我们为 _App_ 根组件绑定一个点击事件，如下：

```js
import { useState } from 'react'
import Modal from './components/Modal'
function App() {
  const [isShow, setIsShow] = useState(false)
  return (
    <div
      style={{
        position: 'relative',
      }}
      onClick={() => console.log('App 组件被点击了')}
    >
      <h1>App组件</h1>
      <button onClick={() => setIsShow(!isShow)}>显示/隐藏</button>
      {isShow ? <Modal /> : null}
    </div>
  )
}

export default App
```

之后我们点击模态框，会发现仍然是能够触发 _App_ 根组件的点击事件。

正如官方文档所说：

> 尽管 _portal_ 可以被放置在 _DOM_ 树中的任何地方，但在任何其他方面，其行为和普通的 _React_ 子节点行为一致。由于 _portal_ 仍存在于 _React_ 树， 且与 _DOM_ 树中的位置无关，那么无论其子节点是否是 _portal_，像 _context_ 这样的功能特性都是不变的。
>
> 这包含事件冒泡。一个从 _portal_ 内部触发的事件会一直冒泡至包含 _React_ 树的祖先，即便这些元素并不是 _DOM_ 树中的祖先。

-_EOF_-
