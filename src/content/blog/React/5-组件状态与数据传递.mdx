---
title: 组件状态与数据传递
description: 组件状态与数据传递
pubDate: 2025-10-11
toc: true
ogImage: true
category: React
---

本章主要包含以下知识点：

- 组件状态
- _props_
- _props_ 验证
- 状态提升

## 组件状态

早期类组件被称之为有状态组件，就是因为在类组件中能够维护组件数据。

```js
class 类名 extends React.Component{
  constructor(){
    super();
    // 设置组件自身的数据状态
    this.state = {
      xxx : xxx
    }
  }
  render(){
    return (
    	// 通过 {this.state.xxx} 来获取状态数据
    )
  }
}

// 或者
class 类名 extends React.Component{
  state = {
      xxx : xxx
  }
  render(){
    return (
    	// 通过 {this.state.xxx} 来获取状态数据
    )
  }
}
```

不要直接去修改状态值，而是应该通过 _setState_ 方法修改组件的 _state_ 状态数据。

```js
this.setState({
  xxx: 新值,
})
```

_setState_，它对状态的改变，**可能**是异步的。

> 如果改变状态的代码处于某个 _HTML_ 元素的事件中，则其是异步的，否则是同步

如果在事件处理函数里面想拿到 _setState_ 执行后的数据，可以提前使用一个变量来存储计算结果，或者使用 _setState_ 的第二个参数，它是一个函数，这个函数会在 _state_ 更新后被调用。

最佳实践：

1. 把所有的 _setState_ 当作是异步的
2. 永远不要信任 _setState_ 调用之后的状态
3. 如果要使用改变之后的状态，需要使用回调函数（_setState_ 的第二个参数）
4. 如果新的状态要根据之前的状态进行运算，使用函数的方式改变状态（_setState_ 的第一个函数）

_React_ 会对异步的 _setState_ 进行优化，将多次 _setState_ 进行合并（将多次状态改变完成后，再统一对 _state_ 进行改变，然后触发 _render_）

## _props_

和 _Vue_ 一样，在 _React_ 中组件会存在层级关系，那么自然会涉及到组件之间进行数据的传递。

如果是父组件向子组件传递数据，则使用 _props_。

如果是函数组件，_props_ 作为函数的一个参数传入：

```react
function 组件名(props) {
  return (
    // 一段 JSX
    // 通过 props.xxx 获取传入的值
    <div>
      <p>姓名：{props.name}</p>
      <p>年龄：{props.age}</p>
      <p>性别：{props.gender}</p>
    </div>
  );
}
```

如果是类组件，则需要在 _constructor_ 中将 _props_ 通过 _super_ 传递给父类，然后通过 _this.props_ 的方式来获取传入的值：

```react
class 组件名 extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
       // 一段 JSX
    	 // 通过 this.props.xxx 获取传入的值
        <div>
          <p>姓名：{this.props.name}</p>
          <p>年龄：{this.props.age}</p>
          <p>性别：{this.props.gender}</p>
        </div>
     );
	}
}
```

通过 _props.children_，可以实现类似于 _Vue_ 中插槽的功能，例如：

```react
class 组件B extends React.Component{
  constructor(props){
    super(props);
  }
  render(){
    return (
      <div>
          {this.props.children}
      </div>
    );
  }
}
class 组件A extends React.Component{
  constructor(props){
    super(props);
  }
  render(){
    return (
      <组件B>
        <p>Hello, React</p>
        <p>Hello, Redux</p>
        <p>Hello, Facebook</p>
        <p>Hello, Google</p>
      </组件B>
    );
  }
}
```

## _props_ 验证

在 _Vue_ 中，可以对传入的 _props_ 设置默认值，以及验证 _props_ 的有效性，在 _React_ 中，针对 _props_ 也可以做这些事。

通过 _defaultprops_ 就可以对 _props_ 设置默认值。

```react
function Greeting(props) {
  const { name, age, gender } = props;
  return (
    <div>
      <p>姓名：{name}</p>
      <p>年龄：{age}</p>
      <p>性别：{gender}</p>
    </div>
   );
}
// 设置默认的 props 值，当组件没有传值时会使用默认值
Greeting.defaultProps = {
  name : 'xiejie',
  age : 18,
  gender : 'male'
};
```

```react
class Greeting extends React.Component {
  constructor(props) {
    super(props);
  }
  // 设置默认的 defaultProps 属性值
  static defaultProps = {
    name : "xiejie",
    age : 18,
    gender : 'male'
  }
  render() {
    return (
      <div>
        <p>姓名：{this.props.name}</p>
        <p>姓名：{this.props.age}</p>
        <p>姓名：{this.props.gender}</p>
      </div>
    );
  }
}
// 或者
Greeting.defaultProps = {
    name : "xiejie",
    age : 18,
    gender : 'male'
}
```

关于 _props_ 的类型检查，从 _React v15.5_ 版本开始，移入到了 [`prop-types` 库](https://www.npmjs.com/package/prop-types) 。

```react
import PropTypes from 'prop-types';

class Greeting extends React.Component {
  render() {
    return (
      <h1>Hello, {this.props.name}</h1>
    );
  }
}

Greeting.propTypes = {
  name: PropTypes.string
};
```

```react
import PropTypes from 'prop-types'

function HelloWorldComponent({ name }) {
  return (
    <div>Hello, {name}</div>
  )
}

HelloWorldComponent.propTypes = {
  name: PropTypes.string
}

export default HelloWorldComponent
```

## 状态提升

在 _Vue_ 中，父传子通过 _props_，子传父通过触发自定义事件。

在 _React_ 中，如果子组件需要向父组件传递数据，同样是通过触发父组件传递给子组件的事件来进行传递。

这在官网中被称之为“状态提升”：*https://zh-hans.reactjs.org/docs/lifting-state-up.html*

汇率转换案例：

父组件

```react
import React from "react";
import Money from "./component/Money";

// 类组件
class App extends React.Component {
  state = {
    dollar: "",
    rmb: ""
  }

  transformToRMB = (value) => {
    if (parseFloat(value) || value === "" || parseFloat(value) === 0) {
      this.setState({
        dollar: value,
        rmb: value === "" ? "" : (value * 7.3255).toFixed(2)
      })
    } else {
      alert("请输入数字");
    }
  }

  transformToDollar = (value) => {
    if (parseFloat(value) || value === "" || parseFloat(value) === 0) {
      this.setState({
        dollar: value === "" ? "" : (value * 0.1365).toFixed(2),
        rmb: value
      })
    } else {
      alert("请输入数字");
    }
  }

  render() {
    return (
      <div>
        <Money text="美元" money={this.state.dollar} transform={this.transformToRMB} />
        <Money text="人民币" money={this.state.rmb} transform={this.transformToDollar} />
      </div>
    )
  }

}

export default App;
```

子组件

```react
import React from 'react';

function Money(props) {


    function handleChange(e){
       // 在子组件中，要做的事情很简单，将用户数据的值，传递给父组件
       // 让父组件来进行修改
       props.transform(e.target.value);
    }


    return (
        <fieldset>
            <legend>{props.text}</legend>
            <input type="text" value={props.money} onChange={handleChange}/>
        </fieldset>
    );
}

export default Money;
```

---

-_EOF_-
